<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/medium-articles/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/medium-articles/css/franklin.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
<link rel="stylesheet" href="/medium-articles/css/font-awesome.min.css">
<link rel="stylesheet" href="/medium-articles/css/celeste.min.css">
<link rel="stylesheet" href="/medium-articles/css/custom.css">

<link rel="icon" type="image/png" sizes="192x192" href="/medium-articles/assets/favicon.png">
<link rel="shortcut icon" href="/medium-articles/assets/favicon.ico">


   <title>Parte 3 - Estruturas de dados I</title>  
</head>
<body>
  <header>
<nav class="nav-main">
  <ul>
    <li class="logo"><a class="hvr-ripple-out" href="/medium-articles/">W</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/medium/">Medium Articles</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/transport-phenomena/">Transport Phenomena</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/julia-para-cientistas/">Julia para Cientistas</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/engenharia-de-reatores/">Engenharia de Reatores</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/bookmarks/">Links</a></li>
  </ul>
</nav>
</header>


<!-- Content appended here -->
<div class="franklin-content">
<h1 id="parte_3_-_estruturas_de_dados_i"><a href="#parte_3_-_estruturas_de_dados_i" class="header-anchor">Parte 3 - Estruturas de dados I</a></h1>
<p>Nesta se√ß√£o vamos estudar alguns tipos de estruturas de dados. Essas formas <em>compostas</em> s√£o constru√≠das sobre elementos que j√° vimos mas podem tamb√©m ir al√©m destes. Abordaremos apenas as caracter√≠sticas b√°sicas de cada uma das estruturas apresentadas e os casos de aplica√ß√£o se tornar√£o evidentes. Os diversos m√©todos comuns √† essas cole√ß√µes √© descrito <a href="https://docs.julialang.org/en/v1/base/collections/">nesta p√°gina</a>.</p>
<h2 id="tuples"><a href="#tuples" class="header-anchor"><em>Tuples</em></a></h2>
<p>Uma <em>tuple</em> √© constitu√≠da de uma sequ√™ncia de elementos, que podem ser de tipos diferentes, declarada entre par√™ntesis. A caracter√≠stica de base de uma <em>tuple</em> √© sua imutabilidade: uma vez declarada, seus elementos n√£o podem ser alterados.</p>
<div class="note"><div class="title">‚ö†  J√° vimos isso antes</div>
<div class="content">Voltando a se√ß√£o aonde realizamos a convers√£o expl√≠cita de tipos acima, voc√™ pode verificar que na realidade j√° utilizamos uma tuple de n√∫meros indicando as intensidades RGB de uma cor.</div></div>
<p>Declaremos uma sequ√™ncia fixa de linguagens de programa√ß√£o dadas por seus nomes como <code>Strings</code>:</p>
<pre><code class="language-julia">languages &#61; &#40;&quot;Julia&quot;, &quot;Python&quot;, &quot;Octave&quot;&#41;</code></pre><pre><code class="plaintext code-output">("Julia", "Python", "Octave")</code></pre>
<p>Inspecionando o tipo desta vari√°vel aprendemos mais uma caracter√≠stica importante inerente a defini√ß√£o de <code>Tuple</code> feita acima quanto ao seu car√°ter imut√°vel: o tipo de uma <code>Tuple</code> inclui individualmente o tipo de cada um de seus elementos. Dito de outra maneira, uma sequ√™ncia composta de um n√∫mero definido de objetos de dados tipos caracteriza por ela mesmo um novo tipo de dados.</p>
<pre><code class="language-julia">typeof&#40;languages&#41;</code></pre><pre><code class="plaintext code-output">Tuple{String, String, String}</code></pre>
<p>Os elementos de uma <code>Tuple</code> podem ser acessados por seus √≠ndices.</p>
<div class="warning"><div class="title">‚ö†  Indices em Julia</div>
<div class="content">√â o momento de mencionar que em Julia a indexa√ß√£o inicia com <code>1</code>.</div></div>
<pre><code class="language-julia">@show languages&#91;1&#93;</code></pre><pre><code class="plaintext code-output">languages[1] = "Julia"
</code></pre>
<p>Vamos tentar modificar o segundo elemento da <code>Tuple</code>.</p>
<div class="note"><div class="title">‚ö†  Sintaxe de controle de erros</div>
<div class="content">Ainda √© cedo para entrar nos detalhes, mas aproveite o bloco abaixo para ter um primeiro contato com a gest√£o de erros em Julia.</div></div>
<pre><code class="language-julia">try
    languages&#91;2&#93; &#61; &quot;C&#43;&#43;&quot;
catch err
    println&#40;&quot;Erro: &#36;&#40;err&#41;&quot;&#41;
end</code></pre><pre><code class="plaintext code-output">Erro: MethodError(setindex!, (("Julia", "Python", "Octave"), "C++", 2), 0x0000000000007b16)
</code></pre>
<p>Existem certas subtilidades que voc√™ precisa saber sobre a imutabilidade. Observe o exemplo abaixo, aonde declaramos duas vari√°veis que s√£o utilizadas para construir uma <code>Tuple</code> e ent√£o modificamos uma das vari√°veis: a <code>Tuple</code> continua com os valores originais do momento da sua constru√ß√£o.</p>
<pre><code class="language-julia">let
    a &#61; 1
    b &#61; 2

    test_tuple &#61; &#40;a, b&#41;

    a &#61; 5
    test_tuple
end</code></pre><pre><code class="plaintext code-output">(1, 2)</code></pre>
<div class="warning"><div class="title">‚ö†  Isso nem sempre √© verdade&#33;</div>
<div class="content">Se o elemento compondo a <code>Tuple</code> for de um tipo mut√°vel, como √© o caso de <code>Array</code>&#39;s, como veremos no que se segue, os elementos desta vari√°vel podem ser modificados e impactam a <code>Tuple</code> diretamente. Isso se d√° porque neste caso a <code>Tuple</code> conserva a refer√™ncia ao objeto em quest√£o, e n√£o uma c√≥pia dos valores, como √© o caso para tipos de base.</div></div>
<pre><code class="language-julia">let
    a &#61; 1
    b &#61; &#91;1, 2&#93;

    test_tuple &#61; &#40;a, b&#41;

    b&#91;1&#93; &#61; 999
    test_tuple
end</code></pre><pre><code class="plaintext code-output">(1, [999, 2])</code></pre>
<h2 id="named_tuples"><a href="#named_tuples" class="header-anchor"><em>Named tuples</em></a></h2>
<p>Esta extens√£o √† <code>Tuples</code> adiciona a possibilidade de acesso aos componentes por um <em>nome</em> no lugar de um simples √≠ndice ‚Äì que continua funcional como veremos abaixo. Esse tipo de estrutura √© bastante √∫til quando necessitamos criar abstra√ß√µes de coisas bastante simples para as quais a cria√ß√£o de um novo tipo n√£o se justifica. Discutiremos mais tarde quando vamos estudar a cria√ß√£o de <em>novos tipos</em>.</p>
<pre><code class="language-julia">named_languages &#61; &#40;julia &#61; &quot;Julia&quot;, python &#61; &quot;Python&quot;&#41;</code></pre><pre><code class="plaintext code-output">(julia = "Julia", python = "Python")</code></pre>
<p>Observe o fato de que agora os nomes utilizados no √≠ndex fazem parte do tipo.</p>
<pre><code class="language-julia">typeof&#40;named_languages&#41;</code></pre><pre><code class="plaintext code-output">@NamedTuple{julia::String, python::String}</code></pre>
<p>Abaixo verificamos que al√©m do acesso por nomes, <code>NamedTuples</code> tamb√©m respeitam a ordem de declara√ß√£o dos elementos: <code>:julia</code> √© o primeiro √≠ndice. A sintaxe de acesso aos elementos neste caso √© com a nota√ß√£o t√≠pica utilizando um ponto, comum a diversas linguages de programa√ß√£o.</p>
<pre><code class="language-julia">named_languages&#91;1&#93; &#61;&#61; named_languages.julia</code></pre><pre><code class="plaintext code-output">true</code></pre>
<h2 id="dicion√°rios"><a href="#dicion√°rios" class="header-anchor">Dicion√°rios</a></h2>
<p>Objetos do tipo <code>Dict</code> possuem a similaridade com <code>NamedTuples</code> em que seus elementos podem ser acessados por nome. No entanto a sintaxe √© diferente e os valores desta estrutura s√£o mut√°veis.</p>
<pre><code class="language-julia">organs &#61; Dict&#40;&quot;brain&quot; &#61;&gt; &quot;üß†&quot;, &quot;heart&quot; &#61;&gt; &quot;‚ù§&quot;&#41;</code></pre><pre><code class="plaintext code-output">Dict{String, String} with 2 entries:
  "brain" => "üß†"
  "heart" => "‚ù§"</code></pre>
<p>O acesso a elementos se faz com colchetes contendo o √≠ndex como se segue:</p>
<pre><code class="language-julia">organs&#91;&quot;brain&quot;&#93;</code></pre><pre><code class="plaintext code-output">"üß†"</code></pre>
<p>E como dissemos, os elementos s√£o mut√°veis: vamos atribuir um burrito ao c√©rebro.</p>
<pre><code class="language-julia">organs&#91;&quot;brain&quot;&#93; &#61; &quot;üåØ&quot;</code></pre><pre><code class="plaintext code-output">"üåØ"</code></pre>
<p>N√£o s√≥ os elementos, mas o dicion√°rio como um todo, pode ser alterado. Para adicionar novos elementos simplesmente <em>acessamos</em> a palavra-chave e atribu√≠mos um valor:</p>
<pre><code class="language-julia">organs&#91;&quot;eyes&quot;&#93; &#61; &quot;üëÄ&quot;</code></pre><pre><code class="plaintext code-output">"üëÄ"</code></pre>
<p>Internamente para evitar nova aloca√ß√£o de mem√≥ria a cada tentativa de se adicionar um novo elemento, um dicion√°rio realiza a aloca√ß√£o de <code>slots</code> que s√£o renovados cada vez que sua capacidade √© ultrapassada. Observe que a lista retornada abaixo √© composta majoritariamente de <code>0x00</code>, que √© o endere√ßo de mem√≥ria nulo, enquanto 3 elementos indicam um valor n√£o-nulo, correspondendo aos elementos j√° adicionados ao dicion√°rio. Disto vemos que adicionalmente um dicion√°rio n√£o preserva necessariamente uma sequ√™ncia ordenada. Esses detalhes ultrapassam o presente escopo mas v√£o abrindo as portas para assuntos mais complexos.</p>
<pre><code class="language-julia">organs.slots
organs</code></pre><pre><code class="plaintext code-output">Dict{String, String} with 3 entries:
  "brain" => "üåØ"
  "heart" => "‚ù§"
  "eyes" => "üëÄ"</code></pre>
<p>Para remover elementos utilizamos a fun√ß√£o <code>pop&#33;</code>. Por conven√ß√£o em Julia, fun√ß√µes que terminam por um ponto de exclama√ß√£o modificam os argumentos que s√£o passados. No caso de <code>pop&#33;</code> o dicion√°rio √© modificado e o valor de retorno √© aquele do elemento removido.</p>
<pre><code class="language-julia">pop&#33;&#40;organs, &quot;brain&quot;&#41;</code></pre><pre><code class="plaintext code-output">"üåØ"</code></pre>
<p>A tentativa de remover um elemento inexistente obviamente conduz √† um erro:</p>
<pre><code class="language-julia">try
    pop&#33;&#40;organs, &quot;leg&quot;&#41;
catch err
    println&#40;&quot;Erro: &#36;&#40;err&#41;&quot;&#41;
end
organs</code></pre><pre><code class="plaintext code-output">Erro: KeyError("leg")
Dict{String, String} with 2 entries:
  "heart" => "‚ù§"
  "eyes" => "üëÄ"</code></pre>
<p>Para evitar essa possibilidade podemos usar a fun√ß√£o <code>haskey&#40;&#41;</code>.</p>
<pre><code class="language-julia">haskey&#40;organs, &quot;liver&quot;&#41;</code></pre><pre><code class="plaintext code-output">false</code></pre>
<p>Uma √∫ltima coisa a notar √© que <em>praticamente</em> qualquer tipo b√°sico pode ser empregado como a chave de um dicion√°rio em Julia. Veja o exemplo √† seguir:</p>
<pre><code class="language-julia">music &#61; Dict&#40;:violin &#61;&gt; &quot;üéª&quot;, 1 &#61;&gt; 2&#41;</code></pre><pre><code class="plaintext code-output">Dict{Any, Any} with 2 entries:
  :violin => "üéª"
  1 => 2</code></pre>
<p>Como as chaves s√£o de tipos diferentes &#40;um <code>Symbol</code> e um <code>Int64</code>&#41;, assim como os valores &#40;uma <code>String</code> e um <code>Int64</code>&#41;, a fun√ß√£o <code>typeof&#40;&#41;</code> nos retorna tipos <code>Any</code>.</p>
<pre><code class="language-julia">typeof&#40;music&#41;</code></pre><pre><code class="plaintext code-output">Dict{Any, Any}</code></pre>
<p>Ainda nos restam alguns detalhes e tipos de dados, mas o tutorial come√ßa a ficar longo... e n√£o queremos te perder por aqui&#33;</p>
<p>Isso √© tudo para esta sess√£o de estudo&#33; At√© a pr√≥xima&#33;</p>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Walter Dal'Maz Silva -
    Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/medium-articles/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
