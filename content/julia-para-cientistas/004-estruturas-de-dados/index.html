<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
   <link rel="stylesheet" href="/medium-articles/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/medium-articles/css/franklin.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
<link rel="stylesheet" href="/medium-articles/css/font-awesome.min.css">
<link rel="stylesheet" href="/medium-articles/css/celeste.min.css">
<link rel="stylesheet" href="/medium-articles/css/custom.css">

<link rel="icon" type="image/png" sizes="192x192" href="/medium-articles/assets/favicon.png">
<link rel="shortcut icon" href="/medium-articles/assets/favicon.ico">


   <title>Parte 4 - Estruturas de dados II</title>  
</head>
<body>
  <header>
<nav class="nav-main">
  <ul>
    <li class="logo"><a class="hvr-ripple-out" href="/medium-articles/">W</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/medium/">Medium Articles</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/transport-phenomena/">Transport Phenomena</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/julia-para-cientistas/">Julia para Cientistas</a></li>
    <li class="hvr-underline-reveal"><a href="/medium-articles/content/engenharia-de-reatores/">Engenharia de Reatores</a></li>
  </ul>
</nav>
</header>


<!-- Content appended here -->
<div class="franklin-content">
<h1 id="parte_4_-_estruturas_de_dados_ii"><a href="#parte_4_-_estruturas_de_dados_ii" class="header-anchor">Parte 4 - Estruturas de dados II</a></h1>
<p>Neste notebook estudamos a sequência de estruturas de dados básicas iniciada no precedente. O foco aqui são tipos úteis em cálculo numérico e álgebra linear, embora suas aplicação vaiam muito além.</p>
<h2 id="arrays"><a href="#arrays" class="header-anchor"><em>Arrays</em></a></h2>
<p>A estrutura <code>Array</code> se diferencia de <code>Tuple</code> pelo fato de ser mutável e de <code>Dict</code> pela noção de ordem. Dadas essas características não é surpreendente que seja esse o tipo de base sobre o qual Julia constrói vetores e matrizes, embora um <code>Array</code> seja mais genérico que esses conceitos matemáticos. Podemos, por exemplo, construir um <code>Array</code> contendo sub-<code>Array</code>&#39;s de tamanho variável, o que não constituiria uma matriz. Ou então misturar tipos de dados nos elementos de um <code>Array</code>, como mostramos ser possível com <code>Tuple</code>.</p>
<p>Em termos de sintaxe, usamos nesse caso colchetes <code>&#91;&#93;</code> para limitar a sequência.</p>
<p>Considere por exemplo a seguinte lista de países...</p>
<pre><code class="language-julia">countries &#61; &#91;&quot;France&quot;, &quot;Brazil&quot;, &quot;Germany&quot;&#93;</code></pre><pre><code class="plaintext code-output">3-element Vector{String}:
 "France"
 "Brazil"
 "Germany"</code></pre>
<p>...ou então de números,...</p>
<pre><code class="language-julia">numbers &#61; &#91;1, 2, 3.1&#93;</code></pre><pre><code class="plaintext code-output">3-element Vector{Float64}:
 1.0
 2.0
 3.1</code></pre>
<p>..., ou simplesmente informações pessoais.</p>
<pre><code class="language-julia">personal_info &#61; &#91;&quot;Walter&quot;, 34, &quot;Lyon&quot;&#93;</code></pre><pre><code class="plaintext code-output">3-element Vector{Any}:
   "Walter"
 34
   "Lyon"</code></pre>
<p>O acesso a elementos se faz através de índices, como em <code>Tuple</code>.</p>
<pre><code class="language-julia">personal_info&#91;2&#93;</code></pre><pre><code class="plaintext code-output">34</code></pre>
<p>Como essa estrutura é mutável ela suporta – <a href="https://docs.julialang.org/en/v1/base/arrays/">entre muitos outros</a> – o método <code>push&#33;&#40;&#41;</code> para se adicionar um elemento após o último.</p>
<pre><code class="language-julia">push&#33;&#40;personal_info, &quot;Engineer&quot;&#41;</code></pre><pre><code class="plaintext code-output">4-element Vector{Any}:
   "Walter"
 34
   "Lyon"
   "Engineer"</code></pre>
<p>De maneira similar ao que vimos para <code>Dict</code>, uma implementação de <code>pop&#33;&#40;&#41;</code> é disponível para o tipo <code>Array</code>, realizando a operação inversa de <code>push&#33;&#40;&#41;</code>.</p>
<pre><code class="language-julia">pop&#33;&#40;personal_info&#41;</code></pre><pre><code class="plaintext code-output">"Engineer"</code></pre>
<p>O exemplo de uma <em>não-matriz</em> citado na introdução é apresentado a seguir.</p>
<pre><code class="language-julia">not_a_matrix &#61; &#91;&#91;1, 2, 3&#93;, &#91;4, 5&#93;, &#91;6, 7, 8, 9&#93;&#93;</code></pre><pre><code class="plaintext code-output">3-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [4, 5]
 [6, 7, 8, 9]</code></pre>
<p>Usando <code>typeof&#40;&#41;</code> descobrimos que se trata de um <code>Vector</code> de <code>Vector</code> e que na verdade Julia usa <code>Vector</code> com um <em>alias</em> para um <code>Array&#123;T, 1&#125;</code>, aonde <code>T</code> denota o tipo de dado.</p>
<pre><code class="language-julia">typeof&#40;not_a_matrix&#41;</code></pre><pre><code class="plaintext code-output">Vector{Vector{Int64}} (alias for Array{Array{Int64, 1}, 1})</code></pre>
<p>A função <a href="https://docs.julialang.org/en/v1/stdlib/Random/#Base.rand"><code>rand&#40;&#41;</code></a> pode ser usada para criar uma matriz de números aleatórios – e outras estruturas de ordem superior – como se segue. Observe o tipo <code>Matrix&#123;Float64&#125;</code> indicado.</p>
<pre><code class="language-julia">a_matrix &#61; rand&#40;3, 3&#41;</code></pre><pre><code class="plaintext code-output">3×3 Matrix{Float64}:
 0.799934   0.367807  0.350102
 0.0596634  0.261462  0.23509
 0.102789   0.262596  0.00567297</code></pre>
<p>Repetindo a verificação de tipo como fizemos para of <em>vetor de vetores</em> anteriormente, descobrimos que uma <code>Matrix</code> em Julia não é interpretada da mesma maneira, mas como um <code>Array</code> com duas dimensões. Isso é a forma que a linguagem emprega para assegurar as dimensões constantes segundo cada direção da matriz.</p>
<pre><code class="language-julia">typeof&#40;a_matrix&#41;</code></pre><pre><code class="plaintext code-output">Matrix{Float64} (alias for Array{Float64, 2})</code></pre>
<p>Vamos agora atribuir nossa <code>a_matrix</code> à uma outra variável e então modificar a matrix original.</p>
<pre><code class="language-julia">maybe_another_matrix &#61; a_matrix
a_matrix&#91;1, 1&#93; &#61; 999
a_matrix</code></pre><pre><code class="plaintext code-output">3×3 Matrix{Float64}:
 999.0        0.367807  0.350102
   0.0596634  0.261462  0.23509
   0.102789   0.262596  0.00567297</code></pre>
<p>Tal como para a <code>Tuple</code> com objetos mutáveis, atribuir um novo nome à uma matriz não cria uma nova matriz, apenas referencia o seu endereço de memória: observamos abaixo que a tentativa de cópia <code>maybe_another_matriz</code> também é modificada em razão da operação sobre <code>a_matrix</code>.</p>
<pre><code class="language-julia">maybe_another_matrix</code></pre><pre><code class="plaintext code-output">3×3 Matrix{Float64}:
 999.0        0.367807  0.350102
   0.0596634  0.261462  0.23509
   0.102789   0.262596  0.00567297</code></pre>
<p>Quando uma cópia da matriz é necessária devemos utilizar <code>copy&#40;&#41;</code>. Nas próximas células criamos uma matriz e então uma cópia, a qual é modificada, e verificamos não haver impacto na matriz original, validando a cópia em um novo endereço de memória.</p>
<pre><code class="language-julia">another_matrix &#61; rand&#40;2, 2&#41;
again_a_matrix &#61; copy&#40;another_matrix&#41;
again_a_matrix&#91;1, 2&#93; &#61; 0
again_a_matrix
another_matrix</code></pre><pre><code class="plaintext code-output">2×2 Matrix{Float64}:
 0.851694  0.16596
 0.483156  0.482016</code></pre>
<h2 id="ranges"><a href="#ranges" class="header-anchor"><em>Ranges</em></a></h2>
<p>Julia implementa uma variedade de tipos de <em>ranges</em>, iteradores para enumerações ou números espaçados segundo uma regra definida. Os tipos existentes encontram-se documentados em <a href="https://docs.julialang.org/en/v1/base/collections/">collections</a>. O leitor pode interessar-se também pela função mais genérica <a href="https://docs.julialang.org/en/v1/base/math/#Base.range">range</a> da biblioteca padrão.</p>
<p>Vamos começar com a declaração de um <code>UnitRange</code> de números 1 à 10 que pode ser construido com a sintaxe simplificada abaixo.</p>
<pre><code class="language-julia">range_of_numbers &#61; 1:10</code></pre><pre><code class="plaintext code-output">1:10</code></pre>
<p>Confirmamos que trata-se de um <code>UnitRange</code> especializado para o tipo inteiro da arquitetura do computador, 64-bits, tal como o tipo dos elementos usados na construção.</p>
<pre><code class="language-julia">typeof&#40;range_of_numbers&#41;</code></pre><pre><code class="plaintext code-output">UnitRange{Int64}</code></pre>
<p>Essa sintaxe mostrada acima é simplesmente um <em>syntatic sugar</em> para a chamada do construtor padrão deste tipo, como averiguamos na próxima célula.</p>
<pre><code class="language-julia">UnitRange&#40;1, 10&#41;</code></pre><pre><code class="plaintext code-output">1:10</code></pre>
<p>Uma particularidade da sequência criada é que ela não é expandida na memória, mas tão somente a regra de construção para iteração é definida. Verificamos na próxima célula que esta sequência não possui os elementos que esperaríamos.</p>
<pre><code class="language-julia">range_of_numbers</code></pre><pre><code class="plaintext code-output">1:10</code></pre>
<p>Isso é fundamental para se permitir laços de tamanhos enormes, frequentes em computação científica; pode-se, por exemplo, criar uma sequência inteira entre 1 e o máximo valor possível para o tipo <code>Int64</code>:</p>
<pre><code class="language-julia">1:typemax&#40;Int64&#41;</code></pre><pre><code class="plaintext code-output">1:9223372036854775807</code></pre>
<p>Para se expandir a sequência devemos <em>coletar</em> seus valores com <code>collect</code>:</p>
<pre><code class="language-julia">arr &#61; collect&#40;range_of_numbers&#41;</code></pre><pre><code class="plaintext code-output">10-element Vector{Int64}:
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10</code></pre>
<p>O resultado dessa operação é um <code>Vector</code> especializado no tipo usado para a sequência.</p>
<pre><code class="language-julia">typeof&#40;arr&#41;</code></pre><pre><code class="plaintext code-output">Vector{Int64} (alias for Array{Int64, 1})</code></pre>
<p>A inserção de um elemento adicional na sintaxe do tipo <code>start:step:end</code> permite a criação de sequências com um passo determinado. Abaixo usamos um passo de tipo <code>Float64</code> que por razões de precedência numérica vai gerar uma sequência de tipo equivalente, como verificamos no que se segue.</p>
<pre><code class="language-julia">float_range &#61; 0:0.6:10
typeof&#40;float_range&#41;</code></pre><pre><code class="plaintext code-output">StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}</code></pre>
<p>Acima utilizamos um passo de <code>0.6</code> para ilustrar uma particularidade do tipo <code>StepRangeLen</code> que não inclui o último elemento da sequência caso esse não seja um múltiplo inteiro do passo utilizado, de maneira a assegurar que todos os elementos sejam igualmente espaçados.</p>
<pre><code class="language-julia">collect&#40;float_range&#41;</code></pre><pre><code class="plaintext code-output">17-element Vector{Float64}:
 0.0
 0.6
 1.2
 1.8
 2.4
 3.0
 3.6
 4.2
 4.8
 5.4
 6.0
 6.6
 7.2
 7.8
 8.4
 9.0
 9.6</code></pre>
<p>Finalmente, Julia provê <code>LinRange</code>, que será bastante útil para aqueles interessados em métodos numéricos de tipo diferenças finitas ou volumes finitos. Criamos um <code>LinRange</code> fornecendo os limites do intervalo e o número de elementos igualmente espaçados a retornar.</p>
<pre><code class="language-julia">LinRange&#40;1.0, 10.0, 10&#41;</code></pre><pre><code class="plaintext code-output">10-element LinRange{Float64, Int64}:
 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0</code></pre>
<h2 id="atribuição_de_tipos"><a href="#atribuição_de_tipos" class="header-anchor">Atribuição de tipos</a></h2>
<p>Até o momento criamos objetos em Julia sem <em>anotar</em> os tipos de dados requeridos. O compilador de Julia realiza inferência de tipos de maneira bastante avançada para determinar como especializar funções para as entradas dadas. Prover explicitamente tipos, principalmente em interfaces de funções, como veremos no futuro, é altamente recomendável e evita dores de cabeça quanto a validação de um programa quando este ganha em complexidade. Ademais, para computação numérica e aprendizado de máquina, a especificação de tipos tem implicação direta sobre a precisão e performance dos cálculos. É comum, por exemplo, treinar-se redes neurais com dados truncados à <code>Float32</code>, tipo que apresenta performance optimizada nas GPU&#39;s específicas deste ramo, enquanto um cálculo DEM &#40;Discrete Element Method&#41; de colisão de partículas necessida dados <code>Float64</code> &#40;e uma carta gráfica de alto nível adaptada&#41; para prover resultados realistas.</p>
<p>Em Julia especificamos tipos com a sintaxe <code>a::TipoDeA</code>. Isso é valido para variáveis quaisquer, elementos de estruturas de dados, interfaces de funções, etc. Por exemplo, declaremos a seguinte variável:</p>
<pre><code class="language-julia">a::Float32 &#61; 1
typeof&#40;a&#41;</code></pre><pre><code class="plaintext code-output">Float32</code></pre>
<p>Anotamos o tipo <code>Float32</code> para a variável <code>a</code>. No entanto o argumento à direita do sinal de atribuição é um inteiro <code>1</code>. Se deixássemos a <em>descoberta</em> de tipos ao compilador, neste caso obteríamos:</p>
<pre><code class="language-julia">a &#61; 1
typeof&#40;a&#41;</code></pre><pre><code class="plaintext code-output">Float32</code></pre>
<p>Esse resultado pode ser indesejável e incompatível com a interface de alguma função aonde desejamos empregar o valor de <code>a</code>.</p>
<p>Vejamos agora alguns exemplos do impacto no tempo de execução de se prover valores ao lado <em>direito da igualdade</em> adaptados aos tipos esperados na especificação de dados. Vamos usar os <em>ranges</em> que aprendemos logo acima e <code>collect</code> para criar um <code>Vector&#123;Int64&#125;</code>.</p>
<div class="note"><div class="title">⚠  Uso de macros</div>
<div class="content">A <em>macro</em> <code>@benchmark</code> vai executar o código algumas vezes e retornar estatísticas de execução. Não se preocupe com ela por agora, vamos voltar na temática de <em>benchmarking</em> muito em breve.</div></div>
<pre><code class="language-julia">using BenchmarkTools, Statistics
@benchmark a::Vector&#123;Int64&#125; &#61; collect&#40;1:10&#41;</code></pre><pre><code class="plaintext code-output">BenchmarkTools.Trial: 10000 samples with 996 evaluations.
 Range (min … max):  25.066 ns … 540.920 ns  ┊ GC (min … max): 0.00% … 86.90%
 Time  (median):     26.928 ns               ┊ GC (median):    0.00%
 Time  (mean ± σ):   30.544 ns ±  26.850 ns  ┊ GC (mean ± σ):  3.98% ±  4.62%

  ▃█▇▄                                                   ▁▁▁   ▂
  ████▆█▆▆▆▃▁▃▅▅▆▆▅▄▃▄▄▃▄▃▁▅▃▆▅▆▆▄▄▄▄▄▁▃▁▁▁▃▁▃▁▁▁▁▁▁▁▁▄▃▇█████ █
  25.1 ns       Histogram: log(frequency) by time      82.1 ns <

 Memory estimate: 144 bytes, allocs estimate: 1.</code></pre>
<p>Vemos que o tempo de execução é da ordem de 30 ns. Abaixo repetimos essa avaliação para algumas ordens de grandeza de tamanho de <em>arrays</em>. Vemos que o tempo de execução para a criação dos objetos escala com o logaritmo na base 10 do número de elementos.</p>
<pre><code class="language-julia">scalability &#61; &#91;
    mean&#40;&#40;@benchmark a::Vector&#123;Int64&#125; &#61; collect&#40;1:10^1&#41;&#41;.times&#41;
    mean&#40;&#40;@benchmark a::Vector&#123;Int64&#125; &#61; collect&#40;1:10^2&#41;&#41;.times&#41;
    mean&#40;&#40;@benchmark a::Vector&#123;Int64&#125; &#61; collect&#40;1:10^3&#41;&#41;.times&#41;
    mean&#40;&#40;@benchmark a::Vector&#123;Int64&#125; &#61; collect&#40;1:10^4&#41;&#41;.times&#41;
&#93;
log10.&#40;scalability&#41;</code></pre><pre><code class="plaintext code-output">4-element Vector{Float64}:
 1.503709011766098
 2.0189508399987353
 2.78787746640132
 3.632576825384771</code></pre>
<p>Tentemos agora criar um vetor de <code>Float64</code> usando o mesmo método.</p>
<pre><code class="language-julia">@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1:10&#41;</code></pre><pre><code class="plaintext code-output">BenchmarkTools.Trial: 10000 samples with 983 evaluations.
 Range (min … max):  57.575 ns …  1.328 μs  ┊ GC (min … max): 0.00% … 50.52%
 Time  (median):     61.009 ns              ┊ GC (median):    0.00%
 Time  (mean ± σ):   70.525 ns ± 55.430 ns  ┊ GC (mean ± σ):  4.73% ±  6.13%

  ▄█▆▁                                                  ▂▁▁   ▁
  ██████▇█▇▇▆▄▃▅▆▆▆▅▄▅▄▄▃▄▄▄▄▁▄▃▃▄▄▁▄▃▁▁▄▄▃▃▃▃▃▄▁▁▃▄▄▁▆████▇▇ █
  57.6 ns      Histogram: log(frequency) by time       176 ns <

 Memory estimate: 288 bytes, allocs estimate: 2.</code></pre>
<p>O tempo de execução mais que dobrou e a memória estimada foi multiplicada por dois&#33; Isso ocorre porque ao lado direito da expressão fornecemos números inteiros e o compilador é <em>obrigado</em> a incluir uma etapa de conversão de tipos, o que adiciona operações e alocações de memória.</p>
<p>Se na criação do <em>range</em> utilizarmos o tipo esperado de dados voltamos a linha de base da alocação do vetor de inteiros, da ordem de 30 ns e 144 bytes.</p>
<pre><code class="language-julia">@benchmark b::Vector&#123;Float64&#125; &#61; collect&#40;1.0:10.0&#41;</code></pre><pre><code class="plaintext code-output">BenchmarkTools.Trial: 10000 samples with 996 evaluations.
 Range (min … max):  25.147 ns …  1.433 μs  ┊ GC (min … max): 0.00% … 40.75%
 Time  (median):     27.230 ns              ┊ GC (median):    0.00%
 Time  (mean ± σ):   31.711 ns ± 35.882 ns  ┊ GC (mean ± σ):  5.04% ±  4.73%

  ▂▇█▄                                                   ▂▂▁▁ ▂
  ██████▆▅▆▇▆▆▄▆▇▆▅▅▅▅▅▄▄▅▁▅▄▄▄▃▃▃▃▁▁▁▄▁▁▄▃▁▃▃▃▃▁▃▁▁▁▁▃▁█████ █
  25.1 ns      Histogram: log(frequency) by time      80.7 ns <

 Memory estimate: 144 bytes, allocs estimate: 1.</code></pre>
<p>Repetimos o <em>benchmark</em> para comparar a criação de vetores de dupla-precisão inicializados por inteiros e números de dupla precisão. Incluímos no novo <em>benchmark</em> um vetor com um único elemento para entendermos um pouco mais do processo.</p>
<pre><code class="language-julia">with_conversion &#61; let
    scalability &#61; &#91;
        mean&#40;&#40;@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1:10^0&#41;&#41;.times&#41;
        mean&#40;&#40;@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1:10^1&#41;&#41;.times&#41;
        mean&#40;&#40;@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1:10^2&#41;&#41;.times&#41;
        mean&#40;&#40;@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1:10^3&#41;&#41;.times&#41;
    &#93;
    scalability
end</code></pre><pre><code class="plaintext code-output">4-element Vector{Float64}:
   58.39472314720812
   71.50153530010174
  219.84783530655386
 1666.78265</code></pre>
<pre><code class="language-julia">without_conversion &#61; let
    scalability &#61; &#91;
        mean&#40;&#40;@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1.0:10.0^0&#41;&#41;.times&#41;
        mean&#40;&#40;@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1.0:10.0^1&#41;&#41;.times&#41;
        mean&#40;&#40;@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1.0:10.0^2&#41;&#41;.times&#41;
        mean&#40;&#40;@benchmark a::Vector&#123;Float64&#125; &#61; collect&#40;1.0:10.0^3&#41;&#41;.times&#41;
    &#93;
    scalability
end</code></pre><pre><code class="plaintext code-output">4-element Vector{Float64}:
   29.07391817269076
   32.549287751004016
  234.56845375375374
 2011.8570999999997</code></pre>
<p>O vetor <code>with_conversion</code> contém os tempos de execução para a criação de vetores de 1, 10, 100, 1000 e 10000 elementos com conversão de valores de inteiros para dupla-precisão. Observe que os dois primeiros elementos levaram um tempo &#40;aqui em nano-segundos&#41; quase idênticos: existe uma constante de tempo da criação do vetor propriamente dito, a criação dos 10 primeiros elementos é quase negligível nesse caso.</p>
<p>Abaixo calculamos a diferença de tempo entre os dois processos e nos deparamos com mais uma surpresa: para 100 elementos, o tempo de alocação COM conversão é MENOR que o tempo SEM conversão. Ainda é muito cedo e fora de contexto para entrarmos no código LLVM gerado por Julia para entendermos a razão dessa <em>anomalia</em>. O importante a reter aqui é que para vetores de tamanhos importantes &#40;&gt; 1000 elementos&#41; um tempo adicional de execução é adicionado por elemento e isso deve ser levado em conta quando escrevendo código científico.</p>
<pre><code class="language-julia">time_diff &#61; &#40;without_conversion - with_conversion&#41;
time_diff_per_element &#61; time_diff ./ &#91;10^k for k &#61; 0:3&#93;</code></pre><pre><code class="plaintext code-output">4-element Vector{Float64}:
 -29.32080497451736
  -3.895224754909772
   0.14720618447199882
   0.3450744499999996</code></pre>
<p>Espero que a decisão de incluir essas divagações um pouco cedo no aprendizado não sejam deletérias para a motivação do estudante, mas que criem curiosidade quanto aos tópicos mais avançados que veremos mais tarde.</p>
<p>Ainda falta muito para se concluir a introdução à atribuição de tipos, mas esse primeiro contato era necessário para que as próximos tópicos avancem de maneira mais fluida.</p>
<p>Isso é tudo para esta sessão de estudo&#33; Até a próxima&#33;</p>
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Walter Dal'Maz Silva -
    Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
    
        <script src="/medium-articles/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
