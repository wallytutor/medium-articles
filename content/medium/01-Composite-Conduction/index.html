<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,400italic|Source+Code+Pro:400,700" type="text/css">
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/celeste.min.css">
<link rel="stylesheet" href="/css/custom.css">

<link rel="icon" type="image/png" sizes="192x192" href="/assets/favicon.png">
<link rel="shortcut icon" href="/assets/favicon.ico">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/apple-touch-icon.png">

   <title>Steady-state heat transfer</title>  
</head>
<body>
  <header>
<nav class="nav-main">
  <ul>
    <li class="logo"><a class="hvr-ripple-out" href="/">W</a></li>
    <li class="hvr-underline-reveal"><a href="/content/julia-para-cientistas/">Julia para Cientistas</a></li>
  </ul>
</nav>
</header>


<!-- Content appended here -->
<div class="franklin-content">
<h1 id="steady-state_heat_transfer"><a href="#steady-state_heat_transfer" class="header-anchor">Steady-state heat transfer</a></h1>

<h2 id="linear_problem"><a href="#linear_problem" class="header-anchor">Linear problem</a></h2>
<p>Implementation of section 2.2.1 of Nithiarasu <em>et al.</em> &#40;2016&#41; of steady state heat transfer across a composite slab of materials with different thermal conductivities. In one side the slab is irradiated with a heat flux density \(q_1\) while the opposite face is subjected to a convective heat transfer with coefficient \(h\) and ambient temperature \(T_a\). The model to be solved can be stated as</p>
\[
\frac{d^2T}{dx^2}=0
\qquad q_1 = -k_1\frac{dT}{dx}
\qquad q_2 = h (T_3 -
T_a) 
\]
<p>Our goal in what follows is to implement equation &#40;2.12&#41; of the reference to be able to solve for nodal temperatures. To this end we need both the stiffness matrix and the forcing vector of the problem. The code that follows tries to mimic the mathematical implementation rather than following a general programming approach given the introductory level of this example.</p>
<p>Since each component of the composite slab is characterized by a conductivity across the <em>element</em> we provide a function <code>conductivity</code> for computing \(K=kAL^{-1}\). This is more expressive than simply hard-coding its definition directly in the stiffness matrix.</p>
<pre><code class="language-julia">function conductivity&#40;k, A, L&#41;
    return k * A / L
end</code></pre>
<p>Below we implement the stiffness matrix constructor in terms of the required parameters:</p>
<pre><code class="language-julia">function stiffness&#40;h, k1, k2, L1, L2; A&#61;1&#41;
    a1 &#61; conductivity&#40;k1, A, L1&#41;
    a2 &#61; conductivity&#40;k2, A, L2&#41;
    b0 &#61; 0u&quot;W/&#40;m^2*K&#41;&quot;

    return &#91; a1  -a1      b0
            -a1   a1&#43;a2  -a2
             b0  -a2   a2&#43;h*A &#93;;
end</code></pre>
<p>Similarly, the column forcing vector is given as:</p>
<pre><code class="language-julia">function forcing&#40;q, h, Ta; A&#61;1&#41;
    return &#91; q*A;  0u&quot;W/m^2&quot;;  h*A*Ta &#93;;
end</code></pre>
<p>As model parameters one needs to specity the thermal conductivities \(k\) and associated thicknesses \(L\) of plates and the <em>known</em> heat transfer coefficient \(h\) on the side the slab is exposed to convective heat transfer. All these values are provided below with respective physical units.</p>
<pre><code class="language-julia">h &#61; 5u&quot;W/&#40;m^2*K&#41;&quot;
k1 &#61; 5.0u&quot;W/&#40;m*K&#41;&quot;
k2 &#61; 0.5u&quot;W/&#40;m*K&#41;&quot;
L1 &#61; 1.0u&quot;m&quot;
L2 &#61; 1.0u&quot;m&quot;</code></pre>
<p>To complete the boundary conditions, the heat flux \(q_1\) and environment temperature \(T_a\) are given below.</p>
<pre><code class="language-julia">q1 &#61; 20.0u&quot;W/m^2&quot;
Ta &#61; 300.0u&quot;K&quot;</code></pre>
<p>Now we are able to create the problem and inspect elements.</p>
<pre><code class="language-julia">M &#61; stiffness&#40;h, k1, k2, L1, L2&#41;</code></pre><pre><code class="plaintext code-output">3√ó3 Matrix{Unitful.Quantity{Float64, ùêå ùöØ^-1 ùêì^-3, Unitful.FreeUnits{(K^-1, m^-2, W), ùêå ùöØ^-1 ùêì^-3, nothing}}}:
  5.0 W K^-1 m^-2  -5.0 W K^-1 m^-2   0.0 W K^-1 m^-2
 -5.0 W K^-1 m^-2   5.5 W K^-1 m^-2  -0.5 W K^-1 m^-2
  0.0 W K^-1 m^-2  -0.5 W K^-1 m^-2   5.5 W K^-1 m^-2</code></pre>
<pre><code class="language-julia">f &#61; forcing&#40;q1, h, Ta&#41;</code></pre><pre><code class="plaintext code-output">3-element Vector{Unitful.Quantity{Float64, ùêå ùêì^-3, Unitful.FreeUnits{(m^-2, W), ùêå ùêì^-3, nothing}}}:
   20.0 W m^-2
    0.0 W m^-2
 1500.0 W m^-2</code></pre>
<p>Solution is found by solving the linear system with the backslash operator. Because the default operator does not support <code>Unitful</code> units, an overload required <a href="https://github.com/PainterQubits/Unitful.jl/issues/46#issuecomment-1338712249">here</a>. Since the problem is small we will use a matrix inverse here as an alternative.</p>
<pre><code class="language-julia">T &#61; inv&#40;M&#41; * f</code></pre><pre><code class="plaintext code-output">3-element Vector{Unitful.Quantity{Float64, ùöØ, Unitful.FreeUnits{(K,), ùöØ, nothing}}}:
 348.0 K
 344.0 K
 304.0 K</code></pre>
<p>Below we inspect the solution at the nodal positions &#40;filled dots&#41;. Since thermal conductivities were assumed constant in this case, dashed lines extrapolating the linear solution between the nodes are also provided.</p>


    <figure style="text-align:center;">
      <img src="/assets/content/medium/01-Composite-Conduction/code/output/plot-1.png" style="padding:0; width:100%;" alt=" Temperature profile across plate with convection boundary condition."/>
      <figcaption> Temperature profile across plate with convection boundary condition.</figcaption>
    </figure>
    
<h2 id="nonlinear_problem"><a href="#nonlinear_problem" class="header-anchor">Nonlinear problem</a></h2>
<p>Solving the linear problem of steady heat conduction was trivial, but for practical cases &#40;even at low temperatures in many situations&#41; radiation losses should also be taken into account in the currently <em>convective</em> side of the plate. Here we introduce a modification to the boundary condition \(q_2\) accounting for this heat transfer mode. Notice that another source of nonlinearity could be introduced through non-constant thermal conductivities of the media, but we let the reader implement this as an excercise since it is a trivial exntesion to what is provided in what follows.</p>
\[
\frac{d^2T}{dx^2}=0
\qquad
q_1 = -k_1\frac{dT}{dx}
\qquad
q_2 = h (T_3 - T_a) + ŒµœÉ(T_3^4-T_a^4)
\]
<p>There are many ways of handling the nonlinearity introduced by the radiation term. A common approach is the factorization of \(T_3^4-T_a^4\) and reformulation of the boundary condition in terms of a <em>global</em> heat transfer coefficient \(U\). Because \(U\) depends on the <em>last known</em> temperature \(œÑ_3\) the problem needs to be solved iterativelly. The choice of \(œÑ_3\) notation is to distinguish it from the value \(T_3\) found by the linear problem solution.</p>
\[
q_2 = U (T_3 - T_a)
\qquad\text{where}\qquad
U = h + ŒµœÉ(\tau_3+T_a)(\tau_3^2+T_a^2)
\]
<p>The radiation terms introduce the need to provide the surface emissivity \(Œµ\):</p>
<pre><code class="language-julia">Œµ &#61; 0.9</code></pre>
<p>An one-liner <code>globalhtc</code> is provided to evaluate \(U\) at each iteration.</p>
<pre><code class="language-julia">globalhtc&#40;œÑ, Ta, h, Œµ&#41; &#61; h &#43; Œµ * œÉ * &#40;œÑ &#43; Ta&#41; * &#40;œÑ^2 &#43; Ta^2&#41;

@show globalhtc&#40;300u&quot;K&quot;, Ta, h, Œµ&#41;</code></pre><pre><code class="plaintext code-output">globalhtc(300 * u"K", Ta, h, Œµ) = 10.51124 W K^-1 m^-2
</code></pre>
<p>Since the problem now needs to be solved iterativelly, it is worth creating a simple function that encapsulates the steps to be repeated at each iteration, <em>i.e</em> update the heat transfer coefficient, update stiffness matrix and forcing vector, solve for the new temperature estimate. Because this is a dummy problem we will not get an optimized matrix update, but simply call <code>stiffness</code> and <code>forcing</code> every iteration with the new value of <code>U</code>. Because there are many parameters, we create a function that returns another function with the fixed values allowing for a single update:</p>
<pre><code class="language-julia">function createproblem&#40;Ta, h, Œµ, k1, k2, L1, L2&#41;
    function step&#40;œÑ&#41;
        U &#61; globalhtc&#40;œÑ, Ta, h, Œµ&#41;
        M &#61; stiffness&#40;U, k1, k2, L1, L2&#41;
        f &#61; forcing&#40;q1, U, Ta&#41;
        return inv&#40;M&#41; * f
    end
    return step
end</code></pre>
<p>The solution of the problem now is rather simple. One provides an initial guess which is used to compute a new solution estimate. Because under some circumstances the estimate could start wiggling and diverge, it is worth implementing a relaxation step interpolating the new and previous approximations as \(T_{n}=Œ≤T_{n}+(1-Œ≤)T_{n-1}\). In case \(\beta<1\) solution is slowly updated by giving a higher weigth to the previous estimate and the problem is said to be underrelaxed. Overelaxation is the opposite scenario but can be problematic in some cases. Some metric, here the maximum relative change in absolute value, must be used to determine solution convergence.</p>
<pre><code class="language-julia">function solveproblem&#40;T, step; maxiter &#61; 20, rtol &#61; 1.0e-15, Œ≤ &#61; 1.0&#41;
    œÑ &#61; copy&#40;T&#41;

    for i in range&#40;1, maxiter&#41;
        œÑ&#91;:&#93; &#61; Œ≤ * step&#40;T&#91;3&#93;&#41; &#43; &#40;1 - Œ≤&#41; * T
        Œî &#61; maximum&#40;abs.&#40;œÑ .- T&#41; ./ T&#41;
        T&#91;:&#93; &#61; œÑ

        println&#40;&quot;Residual &#36;&#40;i&#41; ..... &#36;&#40;@sprintf&#40;&quot;&#37;.6e&quot;, Œî&#41;&#41;&quot;&#41;

        if Œî &lt; rtol
            break
        end
    end

    return T
end</code></pre>
<p>Below we make use of the created tooling to solve the model.</p>
<pre><code class="language-julia">guess &#61; &#91;Ta; Ta; Ta&#93;

step &#61; createproblem&#40;Ta, h, Œµ, k1, k2, L1, L2&#41;

T &#61; solveproblem&#40;guess, step&#41;</code></pre><pre><code class="plaintext code-output">Residual 1 ..... 1.530091e-01
Residual 2 ..... 3.141345e-05
Residual 3 ..... 1.564581e-07
Residual 4 ..... 7.792353e-10
Residual 5 ..... 3.880841e-12
Residual 6 ..... 1.920556e-14
Residual 7 ..... 0.000000e+00
3-element Vector{Unitful.Quantity{Float64, ùöØ, Unitful.FreeUnits{(K,), ùöØ, nothing}}}:
 345.89328827496115 K
 341.89328827496115 K
 301.89328827496115 K</code></pre>


    <figure style="text-align:center;">
      <img src="/assets/content/medium/01-Composite-Conduction/code/output/plot-2.png" style="padding:0; width:100%;" alt=" Temperature profile across plate with radiation enabled."/>
      <figcaption> Temperature profile across plate with radiation enabled.</figcaption>
    </figure>
    
<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Walter Dal'Maz Silva -
    Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
</div>
</div><!-- CONTENT ENDS HERE -->
    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>
